function f = f(x, m, poles, u_tilde)
%The map F defined in eq 3.15

%Poles = 0 -> no poles
%Poles = 1 -> North pole
%Pole = -1 -> South pole
%Pole = 2 -> Both poles

%Extracting the data from the input
n = (length(x)-2)/4;
u = reshape(x(1:3*n), 3, n);
lambda = x(3*n + 1: 4*n);
alpha = x(4*n + 1);
omega = x(4*n + 2);
u_tilde = reshape(u_tilde, 3, n);

%Setting the necessary constants
zeta = 2*pi/m;
g = [
    cos(zeta),  -sin(zeta), 0;
    sin(zeta),  cos(zeta),  0;
    0,          0,          1
    ];
J_3 = [
    0,  -1, 0;
    1,  0,  0;
    0,  0,  0
    ];
e_3 = [0;0;1];

if isintval(x) == 1
    f = intval(zeros(4*n + 1, 1));
else
    f = zeros(4*n + 1, 1);
end

%Computing G_1, ..., G_n
if isintval(x) == 1
    G = intval(zeros(n,1));
else
    G = zeros(n,1);
end
for j = 1:n
    u_j = u(:, j); 
    G(j) = 1/2 * (norm(u_j)^2 - 1);
end

f(3*n + 1:4*n, 1) = G;

%Computing sum_{j = 1 to n} {J_3*u_tilde_j dot u_j}
transformed_u_tilde = J_3 * u_tilde;

%Reshaping them into a large vector in R^(3*n) so the dot product
%becomes a vector operation instead of a loop
u_line = reshape(u, 1, 3*n);
u_tilde_line = reshape(transformed_u_tilde, 1, 3*n);

f(end) = sum(u_line .* u_tilde_line);

%Computing f_1, ..., f_n
for j = 1:n
    %Extracting u_j
    u_j = u(:,j);
    
    %ring contains the position of all vortices in the jth ring
    %ie, the ring generated by u_j
    if isintval(x) == 1
        ring_j = intval(zeros(3, m));             
    else
        ring_j = zeros(3, m);
    end
    
    for i = 1:m
        ring_j(1:3,i) = g^i * u_j;
    end
    
    %uj_minus_ring contains the difference between  the
    %generator of the jth ring and the position of all vortices
    %in the jth ring
    uj_minus_ring_j = u_j - ring_j;
    
    %we are only summing over i = 1 to i = m-1 , so we remove the last
    %entry corresponding i = m
    uj_minus_ring_j(:,end) = [];
    
    
    %inverse_norm_uj_minus_ring contains 1 over the 2 norm
    %squared of u_j - g^i u_j in its ith coodrinate
    inverse_norm_square_uj_minus_ring_j = sum(uj_minus_ring_j.^(2),1).^(-1);
    
    %We then comptue the first sum in the D_uj h(u) term
    sum1 = uj_minus_ring_j*transpose(inverse_norm_square_uj_minus_ring_j);
    
    %The second sum was too complicated to vectorize, so we compute it
    %using classic loop and incrementing a variable
    sum2 = zeros(3,1);
    
    for j_prime = 1:n
        %We dont include the term j' = j
        if j_prime ~= j
            %Extracting u_j'
            u_j_prime = u(:, j_prime);
            
            %ring_j_prime contains the position of all vortices in the j'th ring
            if isintval(x) == 1
                ring_j_prime = intval(zeros(3,m));
            else
                ring_j_prime = zeros(3, m);
            end
            
            for i = 1:m
                ring_j_prime(1:3,i) = g^i * u_j_prime;
            end
            
            %uj_minus_ring_prime contains the difference between  the
            %generator of the jth ring and the position of all vortices
            %in the j'th ring
            u_j_minus_ring_j_prime = u_j - ring_j_prime;
            
            %inverse_norm_uj_minus_ring_prime contains 1 over the 2 norm
            %squared of u_j - g^i u_j in its ith coodrinate
            inverse_norm_square_uj_minus_ring_j_prime = sum(u_j_minus_ring_j_prime.^(2),1).^(-1);
            
            %We then compute how much we need to increment our sum variable
            sum2 = sum2 + u_j_minus_ring_j_prime*transpose(inverse_norm_square_uj_minus_ring_j_prime);
        end
    end
    
    %The third sum is then straight forwar to compute, so we do so directly
    sum3 = zeros(3,1);
    
    if poles == 1
        sum3 = (u_j - [0;0;1]) * norm(u_j - [0;0;1])^(-2);
    elseif poles == -1
        sum3 = (u_j - [0;0;-1]) * norm(u_j - [0;0;-1])^(-2);
    elseif poles == 2
        north = (u_j - [0;0;1]) * norm(u_j - [0;0;1])^(-2);
        south = (u_j - [0;0;-1]) * norm(u_j - [0;0;-1])^(-2);
        sum3 = north + south;
    end
    
    %Once we have all 3 sums, we then multiply by -m to obtain D_uj h(u)
    del_H = -m*(sum1 + sum2 + sum3);
    
    %Finally, we append the rest of the terms in the definition of f_j
    f(1 + 3*(j-1): 3*j, 1) = del_H - m*omega*e_3 + m*lambda(j)*u_j + alpha*J_3*u_j;
end