function lambda_gen = lambda_generator(u, omega, m, poles)
%Computing the values of lambda which will work for our zero finding problem based on equation 3.15


%Extracting data from the input
n = length(u)/3;
u = reshape(u(1:3*n), 3, n);

%Setting the necessary constants
zeta = 2*pi/m;
g = [
    cos(zeta),  -sin(zeta), 0;
    sin(zeta),  cos(zeta),  0;
    0,          0,          1
    ];

lambda_gen = zeros(n,1);

e3 = [0;0;1];

for j = 1:n
    %{
    u_j = u(:,j);
    
    ring = zeros(3, m);             %Contains the position of all vortices in the jth ring
    for i = 1:m
        ring(1:3,i) = g^i * u_j;
    end
    
    uj_minus_ring = u_j - ring; 
    uj_minus_ring(:,end) = [];
    sum1 = uj_minus_ring*(sum(uj_minus_ring.^(2),1).^(-1))';
    
    sum2 = zeros(3,1);
    
    for j_prime = 1:n
        if j_prime ~= j
            u_j_prime = u(:, j_prime);
            
            ring_prime = zeros(3, m);             %Contains the position of all vortices in the j'th ring
            for i = 1:m
                ring_prime(1:3,i) = g^i * u_j_prime;
            end
    
            u_j_minus_ring_prime = u_j - ring_prime;
            sum2 = sum2 + u_j_minus_ring_prime*(sum(u_j_minus_ring_prime.^(2),1).^(-1))';
        end
    end
    
    sum3 = zeros(3,1);
    
    if poles == 1
        sum3 = (u_j - [0;0;1]) * norm(u_j - [0;0;1])^(-2);
    elseif poles == -1
        sum3 = (u_j - [0;0;-1]) * norm(u_j - [0;0;-1])^(-2);
    elseif poles == 2
        north = (u_j - [0;0;1]) * norm(u_j - [0;0;1])^(-2);
        south = (u_j - [0;0;-1]) * norm(u_j - [0;0;-1])^(-2);
        sum3 = north + south;
    end
    %}
    
    %Extracting u_j
    u_j = u(:,j);
    
    %ring contains the position of all vortices in the jth ring
    %ie, the ring generated by u_j
    ring_j = zeros(3, m);
    
    for i = 1:m
        ring_j(1:3,i) = g^i * u_j;
    end
    
    %uj_minus_ring contains the difference between  the
    %generator of the jth ring and the position of all vortices
    %in the jth ring
    uj_minus_ring_j = u_j - ring_j;
    
    %we are only summing over i = 1 to i = m-1 , so we remove the last
    %entry corresponding i = m
    uj_minus_ring_j(:,end) = [];
    
    
    %inverse_norm_uj_minus_ring contains 1 over the 2 norm
    %squared of u_j - g^i u_j in its ith coodrinate
    inverse_norm_square_uj_minus_ring_j = sum(uj_minus_ring_j.^(2),1).^(-1);
    
    %We then comptue the first sum in the D_uj h(u) term
    sum1 = uj_minus_ring_j*transpose(inverse_norm_square_uj_minus_ring_j);
    
    %The second sum was too complicated to vectorize, so we compute it
    %using classic loop and incrementing a variable
    sum2 = zeros(3,1);
    
    for j_prime = 1:n
        %We dont include the term j' = j
        if j_prime ~= j
            %Extracting u_j'
            u_j_prime = u(:, j_prime);
            
            %ring_j_prime contains the position of all vortices in the j'th ring
            ring_j_prime = zeros(3, m);
            
            for i = 1:m
                ring_j_prime(1:3,i) = g^i * u_j_prime;
            end
            
            %uj_minus_ring_prime contains the difference between  the
            %generator of the jth ring and the position of all vortices
            %in the j'th ring
            u_j_minus_ring_j_prime = u_j - ring_j_prime;
            
            %inverse_norm_uj_minus_ring_prime contains 1 over the 2 norm
            %squared of u_j - g^i u_j in its ith coodrinate
            inverse_norm_square_uj_minus_ring_j_prime = sum(u_j_minus_ring_j_prime.^(2),1).^(-1);
            
            %We then compute how much we need to increment our sum variable
            sum2 = sum2 + u_j_minus_ring_j_prime*transpose(inverse_norm_square_uj_minus_ring_j_prime);
        end
    end
    
    %The third sum is then straight forward to compute, so we do so directly
    sum3 = zeros(3,1);
    
    if poles == 1
        sum3 = (u_j - [0;0;1]) * norm(u_j - [0;0;1])^(-2);
    elseif poles == -1
        sum3 = (u_j - [0;0;-1]) * norm(u_j - [0;0;-1])^(-2);
    elseif poles == 2
        north = (u_j - [0;0;1]) * norm(u_j - [0;0;1])^(-2);
        south = (u_j - [0;0;-1]) * norm(u_j - [0;0;-1])^(-2);
        sum3 = north + south;
    end
    
    lambda_gen(j) = -dot(-(sum1 + sum2 + sum3) - omega*e3, u_j);
end